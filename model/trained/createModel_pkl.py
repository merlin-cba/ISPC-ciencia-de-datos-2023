# -*- coding: utf-8 -*-
"""Copia de CreateModel_pkl.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TuFcp4Pn9oBr5s2PIPMvuRTASvgdDddk

# **Librerías**
"""


#@title uso librerias

# Tratamiento de datos
# ==============================================================================
import numpy as np
import pandas as pd


# Modelado y Forecasting
# ==============================================================================

from skforecast.model_selection import backtesting_forecaster
from skforecast.model_selection import backtesting_forecaster
from skforecast.ForecasterAutoreg import ForecasterAutoreg
from skforecast.ForecasterAutoregCustom import ForecasterAutoregCustom
from skforecast.ForecasterAutoregDirect import ForecasterAutoregDirect
import pickle
from lightgbm import LGBMRegressor




# Configuración warnings
# ==============================================================================
import warnings
warnings.filterwarnings('ignore')

"""# **Datos**"""

# Carga de datos
# ==============================================================================

class GoogleSheetsReader:
    def __init__(self, url):
        self.url = url

    def read(self):
        df_list = pd.read_html(self.url)
        df = pd.DataFrame(df_list[0])
        df.columns = df.iloc[0]
        df = df.iloc[1:]
        return df


# Conversión del formato fecha
# ==============================================================================
class formatoFecha:
    def __init__(self, df):
        self.df = df

    def process_dates(self):
        self.df['Fecha'] = pd.to_datetime(self.df['Fecha'])
        self.df = self.df.set_index('Fecha')
        self.df = self.df.asfreq('60min')
        self.df = self.df.sort_index()
        return self.df


# Backtesting
# Tener en cuenta subir el archivo model.pkl
# ==============================================================================

class Predictor:
    def __init__(self, model_file):
        with open(model_file, 'rb') as file:
            self.forecaster = pickle.load(file)

    def make_predictions(self, data, initial_train_size=47, steps=7, interval=[10, 90], n_boot=1000):
        metric, predictions = backtesting_forecaster(
            forecaster=self.forecaster,
            y=data,
            initial_train_size=initial_train_size,
            fixed_train_size=False,
            steps=steps,
            refit=True,
            interval=interval,
            n_boot=n_boot,
            metric='mean_squared_error',
            verbose=False
        )
        return predictions


class Evaluator:
    def __init__(self, data):
        self.data = data

    def calculate_coverage(self, predictions):
        inside_interval = np.where(
            (self.data.loc[predictions.index, 'Demanda'] >= predictions['lower_bound']) &
            (self.data.loc[predictions.index, 'Demanda'] <= predictions['upper_bound']),
            True,
            False
        )
        coverage = inside_interval.mean()
        return coverage


url = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTGFdnehaioXiuJbzV5zVtyu3jnt5z5-wtNgqJ_WrcfOdq90Qg_j-esIsxRlBq_NDEvr3JKfNkdBRFw/pubhtml'
reader = GoogleSheetsReader(url)
df = reader.read()

processor = formatoFecha(df)
df = processor.process_dates()
df.info()


model_file = 'model.pkl'
predictor = Predictor(model_file)
predictions = predictor.make_predictions(df.Demanda['2021-10-01 00:00':'2021-11-02 23:00'].astype(float))


evaluator = Evaluator(df.astype(float))
coverage = evaluator.calculate_coverage(predictions)
print(f"Cobertura del intervalo predicho con los datos de test: {100 * coverage}")